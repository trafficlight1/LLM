<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—ñ–¥—Å–≤—ñ—Ç–∏—Ç–∏ –ª—ñ—Ö—Ç–∞—Ä LLM v2.1</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --bg-color: #f8f9fa;
            --panel-bg: #ffffff;
            --border-radius: 12px;
            --light-bulb: #f1c40f;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-color);
            height: 100vh; overflow: hidden; 
        }

        .app-container { display: flex; height: 100vh; width: 100%; position: relative; }

        /* --- LOGO --- */
        .app-logo {
            position: absolute;
            top: 30px;
            right: 30px;
            z-index: 50;
        }

        .app-logo img {
            max-width: 120px;
            width: 18vw;
            height: auto;
            display: block;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            width: 400px;
            background: var(--panel-bg);
            z-index: 20;
            display: flex; flex-direction: column;
            box-shadow: 4px 0 24px rgba(0,0,0,0.05);
            flex-shrink: 0;
            overflow-y: auto; 
        }

        .sidebar-content {
            padding: 30px;
            display: flex; flex-direction: column; gap: 16px;
        }

        /* --- MAP --- */
        .map-wrapper { flex-grow: 1; position: relative; z-index: 10; background: #1a1a1a; }
        #map { height: 100%; width: 100%; }

        h3 { margin: 0 0 5px 0; font-weight: 700; font-size: 1.4rem; }
        .description { font-size: 0.9rem; color: #7f8c8d; margin-bottom: 10px; }
        .input-group { display: flex; flex-direction: column; gap: 12px; }
        .street-row { display: flex; gap: 8px; }

        input, select {
            padding: 14px;
            border: 1px solid #e2e6ea;
            border-radius: var(--border-radius);
            font-size: 1rem;
            background: #fdfdfd;
            font-family: inherit;
        }

        #streetPrefix { flex: 0 0 100px; }
        #streetNamePart { flex: 1; }
        #cityInput { display: none; } 

        button {
            border: none; padding: 16px;
            border-radius: var(--border-radius);
            font-size: 1rem; font-weight: 600; cursor: pointer;
            transition: all 0.2s ease; font-family: inherit;
            display: flex; justify-content: center; align-items: center;
        }

        #analyzeBtn { background-color: var(--primary-color); color: white; margin-top: 10px; }
        #analyzeBtn:hover { background-color: #1a252f; transform: translateY(-1px); }
        #analyzeBtn:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        #lightBtn {
            background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            display: none;
            margin-top: 10px;
            animation: pulse 2s infinite;
        }
        #lightBtn:hover { transform: scale(1.02); box-shadow: 0 0 15px rgba(241, 196, 15, 0.4); }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(241, 196, 15, 0); }
            100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); }
        }

        #crossingsBtn { background-color: #95a5a6; color: white; display: none; margin-top: 5px; }
        #crossingsBtn:hover { background-color: #7f8c8d; }

        #resetBtn {
            background-color: #fff; 
            color: var(--error-color); 
            border: 2px solid var(--error-color);
            margin-top: 20px;
        }
        #resetBtn:hover { background-color: var(--error-color); color: white; }

        #status {
            margin-top: 10px; padding: 16px;
            border-radius: var(--border-radius);
            font-size: 0.95rem; line-height: 1.5;
            display: none;
        }
        
        .error-msg { background-color: #fadbd8; color: #c0392b; border-left: 4px solid var(--error-color); }
        .success-msg { background-color: #d4efdf; color: #27ae60; border-left: 4px solid var(--success-color); }

        /* --- RECOMMENDATION CARD --- */
        #recommendations {
            display: none; 
            background: #fff;
            border: 1px solid #e1e8ed;
            border-radius: var(--border-radius);
            padding: 20px; margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.03);
            border-top: 4px solid var(--light-bulb);
        }

        .rec-header { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
        .rec-title { font-weight: 700; color: #34495e; font-size: 1.1rem; }
        .rec-item { margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #f0f0f0; }
        .rec-item:last-child { border-bottom: none; margin-bottom: 0; }
        .rec-label { font-size: 0.8rem; text-transform: uppercase; color: #95a5a6; font-weight: 600; }
        .rec-value { font-size: 1.05rem; font-weight: 600; color: #2c3e50; }

        /* --- LEAFLET POPUP STYLES --- */
        .leaflet-popup-content-wrapper { border-radius: 8px; font-family: 'Inter', sans-serif; }
        .leaflet-popup-content b { color: var(--primary-color); }
        .info-popup-row { margin-bottom: 4px; font-size: 13px; }
        .info-popup-label { font-weight: 600; color: #7f8c8d; margin-right: 5px; }

        /* --- MOBILE --- */
        @media (max-width: 768px) {
            .app-logo img {
                max-width: 90px;
                width: 20vw;
            }

            .app-container { flex-direction: column; }
            .map-wrapper { height: 40vh; order: 1; }
            .sidebar { width: 100%; height: 60vh; order: 2; border-radius: 20px 20px 0 0; margin-top: -15px; }
        }
    </style>
</head>
<body>

<div class="app-container">
    <div class="app-logo">
        <img src="Framelogo.png" alt="Logo">
    </div>
    <aside class="sidebar">
        <div class="sidebar-content">
            <div>
                <h3>–ü—ñ–¥—Å–≤—ñ—Ç–∏—Ç–∏ –ª—ñ—Ö—Ç–∞—Ä LLM</h3>
                <div class="description">–í–≤–µ–¥—ñ—Ç—å –Ω–∞–∑–≤—É –≤—É–ª–∏—Ü—ñ</div>
            </div>
            
            <div class="input-group">
                <input type="hidden" id="cityInput" value="Lviv">
                
                <div class="street-row">
                    <select id="streetPrefix">
                        <option value="–í—É–ª–∏—Ü—è">–í—É–ª.</option>
                        <option value="–ü—Ä–æ—Å–ø–µ–∫—Ç">–ü—Ä–æ—Å–ø.</option>
                        <option value="–ü–ª–æ—â–∞">–ü–ª–æ—â–∞</option>
                    </select>
                    <input type="text" id="streetNamePart" value="–ö–æ–ø–µ—Ä–Ω–∏–∫–∞" placeholder="–ù–∞–∑–≤–∞">
                </div>
            </div>

            <button id="analyzeBtn" onclick="analyzeStreet()">
                <span>–ê–Ω–∞–ª—ñ–∑–∞—Ç–æ—Ä 2.0</span>
            </button>
            
            <div id="recommendations">
                <div class="rec-header">
                    <div class="rec-title">–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó</div>
                </div>
                <div class="rec-item">
                    <div class="rec-label">–©—ñ–ª—å–Ω—ñ—Å—Ç—å –∑–∞–±—É–¥–æ–≤–∏</div>
                    <div class="rec-value" id="rec-density">...</div>
                </div>
                <div class="rec-item">
                    <div class="rec-label">–ö–æ–ª—ñ—Ä–Ω–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞</div>
                    <div class="rec-value" id="rec-temp">...</div>
                </div>
                <div class="rec-item">
                    <div class="rec-label">–¢–∏–ø –∫—Ä—ñ–ø–ª–µ–Ω–Ω—è</div>
                    <div class="rec-value" id="rec-mount">...</div>
                </div>
            </div>

            <button id="lightBtn" onclick="simulateLighting()">
                –°–∏–º—É–ª—è—Ü—ñ—è
            </button>

            <button id="crossingsBtn" onclick="findCrossings()">
                –ó–Ω–∞–π—Ç–∏ –ø–µ—Ä–µ—Ö–æ–¥–∏
            </button>
            
            <div id="results-area">
                <div id="status"></div>
                <div id="stats" class="stats"></div>
            </div>

            <button id="resetBtn" onclick="resetMap()">
                –°–∫–∏–Ω—É—Ç–∏ –∫–∞—Ä—Ç—É
            </button>
        </div>
    </aside>

    <main class="map-wrapper">
        <div id="map"></div>
    </main>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
    // --- –ù–ê–õ–ê–®–¢–£–í–ê–ù–ù–Ø ---
    const WIDTH_ERROR = 2.0;    
    const STEP_METERS = 50;     
    const MAX_SEARCH_DIST = 40; 
    const DENSITY_STEP = 10;
    const BUILDING_SEARCH_RADIUS = 25;

    // //3 –û–±–º–µ–∂–µ–Ω–Ω—è –∫–∞—Ä—Ç–∏ (–õ—å–≤—ñ–≤ + —Ç—Ä–æ—Ö–∏ –æ–∫–æ–ª–∏—Ü—å)
    const LVIV_BOUNDS = [
        [49.75, 23.85], // –ü—ñ–≤–¥–µ–Ω–Ω–∏–π –ó–∞—Ö—ñ–¥
        [49.95, 24.15]  // –ü—ñ–≤–Ω—ñ—á–Ω–∏–π –°—Ö—ñ–¥
    ];

    let savedAreaId = null;
    let savedStreetName = null;
    let savedStreetGeoJSON = null;
    
    let globalAnalysis = {
        avgWidth: 0,
        highwayType: 'residential',
        mountType: 'pole', 
        colorTemp: '3000K'
    };

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∫–∞—Ä—Ç–∏ –∑ –æ–±–º–µ–∂–µ–Ω–Ω—è–º —Å–∫—Ä–æ–ª—É
    const map = L.map('map', {
        maxBounds: LVIV_BOUNDS,
        maxBoundsViscosity: 1.0 // "–õ–∏–ø–∫—ñ" –∫—Ä–∞—ó
    }).setView([49.8419, 24.0315], 13);
    
    const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OSM contributors'
    });
    const lightLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OSM contributors'
    });
    
    // –ó–ú–Ü–ù–ê: –î–æ–¥–∞—î–º–æ darkLayer –∑–∞–º—ñ—Å—Ç—å lightLayer –æ–¥—Ä–∞–∑—É –ø—Ä–∏ —Å—Ç–∞—Ä—Ç—ñ
    darkLayer.addTo(map);

    let mainLayer = L.layerGroup().addTo(map);
    let crossingLayer = L.layerGroup().addTo(map);
    let buildingLayer = L.layerGroup().addTo(map);
    let lightsLayer = L.layerGroup().addTo(map); 

    function updateStatus(msg, type = 'normal') {
        const statusDiv = document.getElementById('status');
        statusDiv.style.display = 'block';
        statusDiv.className = ''; 
        if (type === 'error') {
            statusDiv.innerHTML = `‚ö†Ô∏è ${msg}`;
            statusDiv.classList.add('error-msg');
        } else if (type === 'success') {
            statusDiv.innerHTML = `‚úÖ ${msg}`;
            statusDiv.classList.add('success-msg');
        } else {
            statusDiv.innerHTML = `//${msg}`;
        }
    }

    const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    async function fetchWithRetry(url, options, retries = 3) {
        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(url, options);
                const text = await response.text();
                // Check if response is HTML error page from Overpass
                if (text.trim().startsWith('<') && !text.includes('<osm')) throw new Error("API overloaded");
                return JSON.parse(text);
            } catch (err) {
                if (i === retries - 1) throw err;
                console.log(`Retry ${i+1}/${retries}...`);
                await wait(2500); // –¢—Ä–æ—Ö–∏ –¥–æ–≤—à–∏–π —á–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è
            }
        }
    }

    function resetMap() {
        mainLayer.clearLayers();
        buildingLayer.clearLayers();
        crossingLayer.clearLayers();
        lightsLayer.clearLayers();
        
        savedStreetGeoJSON = null;
        savedStreetName = null;
        
        document.getElementById('status').style.display = 'none';
        document.getElementById('recommendations').style.display = 'none';
        document.getElementById('lightBtn').style.display = 'none';
        document.getElementById('crossingsBtn').style.display = 'none';        
    }
    async function analyzeStreet() {
        const city = document.getElementById('cityInput').value;
        const namePart = document.getElementById('streetNamePart').value.trim();
        const btn = document.getElementById('analyzeBtn');
        if(!city || !namePart || namePart.length < 3) return alert("–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –≤–≤–µ–¥–µ–Ω—ñ –¥–∞–Ω—ñ");
        btn.disabled = true;
        updateStatus(`–®—É–∫–∞—é "${namePart}"...`);

        try {
            const nominatimUrl = `https://nominatim.openstreetmap.org/search?city=${city}&format=json&limit=1`;
            const cityRes = await fetch(nominatimUrl);
            const cityData = await cityRes.json();
            
            if (cityData.length === 0) throw new Error("–ú—ñ—Å—Ç–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ");
            savedAreaId = 3600000000 + parseInt(cityData[0].osm_id);

            // //2 –ó–±—ñ–ª—å—à–µ–Ω–æ —Ç–∞–π–º-–∞—É—Ç –¥–æ 180 —Å–µ–∫—É–Ω–¥ —Ç–∞ –¥–æ–¥–∞–Ω–æ maxsize
            const query = `
                [out:json][timeout:180][maxsize:20000000]; 
                area(${savedAreaId})->.searchArea;
                (way["name"~"${namePart}", i]["highway"](area.searchArea);)->.street;
                (way["highway"~"footway|path|pedestrian|sidewalk"](around.street:${MAX_SEARCH_DIST + 20});)->.sidewalks;
                (way["building"](around.street:30);)->.buildings;
                .street out geom;
                .sidewalks out geom;
                .buildings out geom;
            `;

            const data = await fetchWithRetry('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                body: "data=" + encodeURIComponent(query)
            });

            if (!data.elements || data.elements.length === 0) throw new Error("–í—É–ª–∏—Ü—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.");

            updateStatus("–ê–Ω–∞–ª—ñ–∑ –≥–µ–æ–º–µ—Ç—Ä—ñ—ó...");
            setTimeout(() => { processGeometry(data, namePart); }, 100);

        } catch (error) {
            console.error(error);
            updateStatus(`–ü–æ–º–∏–ª–∫–∞: ${error.message}`, 'error');
        } finally {
            btn.disabled = false;
        }
    }

    function processGeometry(data, searchName) {
        const streetFeatures = [];
        const sidewalkFeatures = [];
        const buildingFeatures = [];
        let foundFullName = null;
        
        let streetMaxLanes = 0;
        let streetHighwayType = 'residential';
        let hasTrolleybus = false;
        const lowerSearch = searchName.toLowerCase();

        data.elements.forEach(el => {
            if (el.type === 'way' && el.geometry) {
                const coords = el.geometry.map(p => [p.lon, p.lat]);
                
                if (el.tags && el.tags.building) {
                    if (coords.length > 2) {
                        coords.push(coords[0]);
                        buildingFeatures.push(turf.polygon([coords], el.tags)); // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ç–µ–≥–∏
                    }
                    return;
                }

                const line = turf.lineString(coords, el.tags);
                const tags = el.tags || {};
                const elName = tags.name ? tags.name.toLowerCase() : "";
                
                const isStreet = elName.includes(lowerSearch) && tags.highway && !tags.highway.match(/footway|path|pedestrian|cycleway/);

                if (isStreet) {
                    streetFeatures.push(line);
                    if (!foundFullName) foundFullName = tags.name;
                    if (tags.highway) streetHighwayType = tags.highway;
                    if (tags.lanes) {
                        const l = parseInt(tags.lanes);
                        if (!isNaN(l) && l > streetMaxLanes) streetMaxLanes = l;
                    }
                    if (tags.trolley_wire === 'yes' || tags.trolleybus === 'yes') hasTrolleybus = true;
                } else if (tags.highway) {
                    sidewalkFeatures.push(line);
                }
            }
        });

        if (streetFeatures.length === 0) return alert("–í—É–ª–∏—Ü—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.");
        
        savedStreetName = foundFullName;
        savedStreetGeoJSON = turf.featureCollection(streetFeatures);

        // 1. –ê–Ω–∞–ª—ñ–∑ –∑–∞–±—É–¥–æ–≤–∏
        const density = calculateDensity(streetFeatures, buildingFeatures);

        // 2. –ê–Ω–∞–ª—ñ–∑ —à–∏—Ä–∏–Ω–∏
        let totalWidth = 0;
        let measurements = 0;
        
        streetFeatures.forEach(streetLine => {
            const length = turf.length(streetLine, {units: 'meters'});
            for (let dist = 10; dist < length - 10; dist += STEP_METERS) {
                const pointOnStreet = turf.along(streetLine, dist, {units: 'meters'});
                const pointAhead = turf.along(streetLine, dist + 5, {units: 'meters'});
                const streetBearing = turf.bearing(pointOnStreet, pointAhead);
                
                let leftP = null, rightP = null;
                let minL = MAX_SEARCH_DIST, minR = MAX_SEARCH_DIST;

                sidewalkFeatures.forEach(sw => {
                    const snapped = turf.nearestPointOnLine(sw, pointOnStreet, {units: 'meters'});
                    const d = snapped.properties.dist;
                    if (d > MAX_SEARCH_DIST || d < 2) return;
                    
                    const bearingToSW = turf.bearing(pointOnStreet, snapped);
                    let rel = bearingToSW - streetBearing;
                    while (rel < -180) rel += 360; while (rel > 180) rel -= 360;

                    if (rel < -45 && rel > -135) { if (d < minL) { minL = d; leftP = snapped; } }
                    else if (rel > 45 && rel < 135) { if (d < minR) { minR = d; rightP = snapped; } }
                });

                if (leftP && rightP) {
                    const w = turf.distance(leftP, rightP, {units: 'meters'}) + WIDTH_ERROR;
                    totalWidth += w;
                    measurements++;
                    
                    // //1 –Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ –ª—ñ–Ω—ñ—è —à–∏—Ä–∏–Ω–∏
                    const poly = L.polyline([
                        [leftP.geometry.coordinates[1], leftP.geometry.coordinates[0]], 
                        [rightP.geometry.coordinates[1], rightP.geometry.coordinates[0]]
                    ], {color: '#e74c3c', weight: 2, opacity: 0.5});

                    poly.bindPopup(`
                        <div class="info-popup-row"><span class="info-popup-label">–†–æ–∑—Ä–∞—Ö—É–Ω–∫–æ–≤–∞ —à–∏—Ä–∏–Ω–∞:</span><b>${w.toFixed(2)} –º</b></div>
                        <div class="info-popup-row"><span class="info-popup-label">–í—ñ–¥—Å—Ç—É–ø –ª—ñ–≤–æ—Ä—É—á:</span>${minL.toFixed(1)} –º</div>
                        <div class="info-popup-row"><span class="info-popup-label">–í—ñ–¥—Å—Ç—É–ø –ø—Ä–∞–≤–æ—Ä—É—á:</span>${minR.toFixed(1)} –º</div>
                    `);
                    poly.addTo(mainLayer);
                }
            }
        });

        const avgWidth = measurements > 0 ? (totalWidth / measurements) : 8; 

        globalAnalysis.avgWidth = avgWidth;
        globalAnalysis.highwayType = streetHighwayType;
        
        let recs = generateRecommendationsData(streetHighwayType, streetMaxLanes, hasTrolleybus, density);
        globalAnalysis.mountType = recs.mountType; 
        globalAnalysis.colorTemp = recs.colorTemp;

        // //1 –Ü–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞ –ª—ñ–Ω—ñ—è –≤—É–ª–∏—Ü—ñ
        L.geoJSON(savedStreetGeoJSON, { 
            style: { color: '#3498db', weight: 5, opacity: 0.6 },
            onEachFeature: function(feature, layer) {
                let p = feature.properties;
                layer.bindPopup(`
                    <div class="info-popup-row"><span class="info-popup-label">–í—É–ª–∏—Ü—è:</span><b>${p.name || savedStreetName}</b></div>
                    <div class="info-popup-row"><span class="info-popup-label">–¢–∏–ø:</span>${p.highway}</div>
                    <div class="info-popup-row"><span class="info-popup-label">–ü–æ–∫—Ä–∏—Ç—Ç—è:</span>${p.surface || '–Ω–µ–≤—ñ–¥–æ–º–æ'}</div>
                `);
            }
        }).addTo(mainLayer);

        if(buildingFeatures.length > 0) L.geoJSON(turf.featureCollection(buildingFeatures), { style: { color: '#555', weight: 1, fillOpacity: 0.1 } }).addTo(buildingLayer);

        const bbox = turf.bbox(savedStreetGeoJSON);
        map.fitBounds([[bbox[1], bbox[0]], [bbox[3], bbox[2]]]);
        
        document.getElementById('lightBtn').style.display = 'block';
        document.getElementById('crossingsBtn').style.display = 'block';
        updateStatus(`–î–æ–¥–∞–Ω–æ: ${foundFullName}. –®–∏—Ä–∏–Ω–∞: ${avgWidth.toFixed(1)}–º`, 'success');
    }

    function calculateDensity(streetLines, buildingPolys) {
        if (buildingPolys.length === 0) return 0;
        const buildingPoints = buildingPolys.map(poly => turf.centroid(poly));
        let total = 0, double = 0;
        streetLines.forEach(line => {
            const len = turf.length(line, {units: 'meters'});
            for (let d = 5; d < len - 5; d += DENSITY_STEP) {
                total++;
                const p1 = turf.along(line, d, {units: 'meters'});
                const p2 = turf.along(line, d + 1, {units: 'meters'});
                const bearing = turf.bearing(p1, p2);
                let l = false, r = false;
                buildingPoints.forEach(bp => {
                    if (turf.distance(p1, bp, {units: 'meters'}) <= BUILDING_SEARCH_RADIUS) {
                        let rel = turf.bearing(p1, bp) - bearing;
                        while (rel < -180) rel += 360; while (rel > 180) rel -= 360;
                        if (rel < 0) l = true; else r = true;
                    }
                });
                if (l && r) double++;
            }
        });
        return total > 0 ? Math.round((double / total) * 100) : 0;
    }

    function generateRecommendationsData(type, lanes, trolley, density) {
        const card = document.getElementById('recommendations');
        
        let temp = "3000K", tempColor = "#ffb74d"; 
        let reasonT = "–ñ–∏—Ç–ª–æ–≤–∞ –≤—É–ª–∏—Ü—è";
        if (['primary', 'trunk'].includes(type)) { 
            temp = "4000K"; tempColor = "#f5f5f5"; reasonT = "–ú–∞–≥—ñ—Å—Ç—Ä–∞–ª—å"; 
        }

        let mount = "–ü—ñ–¥–≤—ñ—Å–Ω–µ";
        let mountCode = "suspended";
        let usePoles = false;
        if (lanes > 3 || trolley || density < 30) usePoles = true;
        
        if (usePoles) { mount = "–û–ø–æ—Ä–∏"; mountCode = "pole"; }

        document.getElementById('rec-density').innerHTML = `${density}% <small>(–ü–æ—Ç—Ä—ñ–±–Ω–æ >30% –¥–ª—è –ø—ñ–¥–≤—ñ—Å—É)</small>`;
        document.getElementById('rec-temp').innerText = `${temp} (${reasonT})`;
        document.getElementById('rec-mount').innerText = mount;
        
        card.style.display = 'block';

        return { mountType: mountCode, colorTemp: temp };
    }

    // --- –õ–û–ì–Ü–ö–ê –°–ò–ú–£–õ–Ø–¶–Ü–á ---
    function preprocessDualCarriageways(features) {
        let processedFeatures = [];
        let usedIndices = new Set();
        const MERGE_DIST = 25; 

        features.sort((a, b) => turf.length(b) - turf.length(a));

        for (let i = 0; i < features.length; i++) {
            if (usedIndices.has(i)) continue;

            const lineA = features[i];
            let foundPair = false;

            for (let j = i + 1; j < features.length; j++) {
                if (usedIndices.has(j)) continue;

                const lineB = features[j];
                const midA = turf.along(lineA, turf.length(lineA) / 2);
                const nearPointOnB = turf.nearestPointOnLine(lineB, midA);
                const dist = nearPointOnB.properties.dist * 1000; 

                if (dist < MERGE_DIST && dist > 4) {
                    const medianLine = createMedianLine(lineA, lineB);
                    if (medianLine) {
                        medianLine.properties.isMedian = true; 
                        processedFeatures.push(medianLine);
                        
                        usedIndices.add(i);
                        usedIndices.add(j);
                        foundPair = true;
                        break; 
                    }
                }
            }

            if (!foundPair) {
                processedFeatures.push(lineA);
                usedIndices.add(i);
            }
        }
        return processedFeatures;
    }

    function createMedianLine(line1, line2) {
        const coords = [];
        const length = turf.length(line1);
        const steps = Math.max(10, Math.floor(length / 10)); 
        
        for (let k = 0; k <= steps; k++) {
            const p1 = turf.along(line1, (length / steps) * k);
            const p2 = turf.nearestPointOnLine(line2, p1);
            const mid = turf.midpoint(p1, p2);
            coords.push(mid.geometry.coordinates);
        }
        if (coords.length > 1) return turf.lineString(coords);
        return null;
    }

    function drawDoubleArmLight(pos, r, color, height) {
        // –û–Ω–æ–≤–ª–µ–Ω–æ: –¥–æ–¥–∞–Ω–∞ —ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ—ó —Ç–æ—á–∫–∏
        drawLightBase(pos, r, color);
        addInteractiveMarker(pos, "–î–≤–æ—Ä—ñ–∂–∫–æ–≤–∞ –æ–ø–æ—Ä–∞", height);
    }

    function simulateLighting() {
        if (map.hasLayer(lightLayer)) map.removeLayer(lightLayer);
        if (typeof darkLayer !== 'undefined') darkLayer.addTo(map);
        const rawFeatures = savedStreetGeoJSON.features;
        const intelligentFeatures = preprocessDualCarriageways(rawFeatures);
        
        updateStatus(`–°–∏–º—É–ª—è—Ü—ñ—è: –¥–æ–¥–∞–Ω–æ —Å–≤—ñ—Ç–ª–æ –¥–ª—è "${savedStreetName}"`);

        let placedLights = []; 
        const COLLISION_THRESHOLD = 12; 

        intelligentFeatures.forEach(feature => {
            const props = feature.properties;
            const isMedian = props.isMedian;
            const length = turf.length(feature, {units: 'meters'});
            
            let W = props.originalWidth || globalAnalysis.avgWidth || 8; 
            let H;
            
            if (globalAnalysis.mountType === 'suspended') {
                H = 8.0; 
            } else if (isMedian) {
                H = 10.0;
            } else {
                H = Math.max(6, Math.min(10, W));
            }

            let spacingRatio = (W < 8) ? 4.0 : 4.5; 
            let S = H * spacingRatio;

            let arrangement;
            const ratio = W / H;

            if (isMedian) {
                arrangement = 'median_double';
                S = H * 4.0; 
            } else if (globalAnalysis.mountType === 'suspended') {
                arrangement = 'axis'; 
                S = H * 3.5; 
            } else {
                if (ratio <= 1.0) { arrangement = 'single'; } 
                else if (ratio <= 1.5) { arrangement = 'staggered'; } 
                else { arrangement = 'opposite'; }
            }

            let visualRadius = H * 1.7;
            if (!isMedian && visualRadius > W * 1.5) visualRadius = W * 1.5; 
            
            const color = globalAnalysis.colorTemp.includes('4000') ? '#eefaff' : '#ffb74d'; 

            for (let d = S / 2; d < length; d += S) {
                const centerP = turf.along(feature, d, {units: 'meters'});
                const nextP = turf.along(feature, d + 1, {units: 'meters'});
                const bearing = turf.bearing(centerP, nextP);

                const tryPlaceLight = (point, type) => {
                    if (!isTooClose(point, placedLights, COLLISION_THRESHOLD)) {
                        drawLight(point, visualRadius, color, type, H); 
                        placedLights.push(point);
                    }
                };

                const offsetDist = (W / 2) + 0.5; 

                switch (arrangement) {
                    case 'median_double':
                        drawDoubleArmLight(centerP, visualRadius, color, H); 
                        placedLights.push(centerP);
                        break;
                    case 'axis':
                        tryPlaceLight(centerP, 'suspended');
                        break;
                    case 'single':
                        const pSingle = turf.destination(centerP, offsetDist / 1000, bearing + 90, {units: 'kilometers'});
                        tryPlaceLight(pSingle, 'pole');
                        break;
                    case 'staggered':
                        const sideAngle = (Math.floor(d/S) % 2 === 0) ? 90 : -90;
                        const pStag = turf.destination(centerP, offsetDist / 1000, bearing + sideAngle, {units: 'kilometers'});
                        tryPlaceLight(pStag, 'pole');
                        break;
                    case 'opposite':
                        const pLeft = turf.destination(centerP, offsetDist / 1000, bearing - 90, {units: 'kilometers'});
                        const pRight = turf.destination(centerP, offsetDist / 1000, bearing + 90, {units: 'kilometers'});
                        tryPlaceLight(pLeft, 'pole');
                        tryPlaceLight(pRight, 'pole');
                        break;
                }
            }
        });
    }

    function isTooClose(newPoint, existingPoints, threshold) {
        for (let pt of existingPoints) {
            const dist = turf.distance(newPoint, pt, {units: 'meters'});
            if (dist < threshold) return true;
        }
        return false;
    }

    function drawLight(pos, radius, color, type, height) {
        drawLightBase(pos, radius, color);
        // //1 –î–æ–¥–∞—î–º–æ —ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
        addInteractiveMarker(pos, type === 'suspended' ? '–ü—ñ–¥–≤—ñ—Å–Ω–∏–π' : '–û–ø–æ—Ä–∞', height);
    }

    function drawLightBase(pos, radius, color) {
        const lat = pos.geometry.coordinates[1];
        const lng = pos.geometry.coordinates[0];

        // –í–µ–ª–∏–∫–∞ –ø–ª—è–º–∞ —Å–≤—ñ—Ç–ª–∞ (–Ω–µ—ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞)
        L.circle([lat, lng], {
            radius: radius,
            color: 'transparent',
            fillColor: color,
            fillOpacity: 0.15, 
            interactive: false
        }).addTo(lightsLayer);

        // –ú–µ–Ω—à–∞ –ø–ª—è–º–∞ (–Ω–µ—ñ–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞)
        L.circle([lat, lng], {
            radius: radius * 0.6, 
            color: 'transparent',
            fillColor: color,
            fillOpacity: 0.3,
            interactive: false
        }).addTo(lightsLayer);
    }

    function addInteractiveMarker(pos, typeName, height) {
        const lat = pos.geometry.coordinates[1];
        const lng = pos.geometry.coordinates[0];

        // –¢–æ—á–∫–∞ —Å–∞–º–æ–≥–æ —Å–≤—ñ—Ç–∏–ª—å–Ω–∏–∫–∞ (–∫–ª—ñ–∫–∞–±–µ–ª—å–Ω–∞)
        const marker = L.circleMarker([lat, lng], {
            radius: 4,
            color: '#333',
            weight: 1,
            fillColor: '#fff',
            fillOpacity: 1,
            interactive: true
        });

        marker.bindPopup(`
            <div class="info-popup-row"><span class="info-popup-label">–¢–∏–ø:</span><b>${typeName}</b></div>
            <div class="info-popup-row"><span class="info-popup-label">–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:</span>${globalAnalysis.colorTemp}</div>
            <div class="info-popup-row"><span class="info-popup-label">–í–∏—Å–æ—Ç–∞:</span>~${height.toFixed(1)} –º</div>
            <div class="info-popup-row" style="color:#aaa; font-size:11px; margin-top:5px;">–°–∏–º—É–ª—è—Ü—ñ—è</div>
        `);
        
        marker.addTo(lightsLayer);
    }

    async function findCrossings() {
        if (!savedAreaId || !savedStreetName) return;
        updateStatus(`–®—É–∫–∞—é –ø–µ—Ä–µ—Ö–æ–¥–∏ –¥–ª—è ${savedStreetName}...`);
        
        // –ó–±—ñ–ª—å—à–µ–Ω–æ —Ç–∞–π–º-–∞—É—Ç
        const query = `[out:json][timeout:60];area(${savedAreaId})->.searchArea;way["name"="${savedStreetName}"]["highway"](area.searchArea)->.street;node["highway"="crossing"](around.street:2);out geom;`;
        
        const data = await fetchWithRetry('https://overpass-api.de/api/interpreter', {method: 'POST', body: "data=" + encodeURIComponent(query)});
        if (!data.elements) return updateStatus("–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ.");
        const streetLines = savedStreetGeoJSON.features; 
        let count = 0;
        data.elements.forEach(el => {
            if (el.type === 'node') {
                const p = turf.point([el.lon, el.lat]);
                let minD = Infinity;
                streetLines.forEach(l => {
                    const d = turf.pointToLineDistance(p, l, {units: 'meters'});
                    if(d<minD) minD = d;
                });
                if(minD <= 2) {
                    const mk = L.marker([el.lat, el.lon], {icon: L.divIcon({className: 'crossing-icon', html: 'üö∂', iconSize: [24, 24]})});
                    mk.bindPopup("<b>–ü—ñ—à–æ—Ö—ñ–¥–Ω–∏–π –ø–µ—Ä–µ—Ö—ñ–¥</b>");
                    mk.addTo(crossingLayer);
                    count++;
                }
            }
        });
        updateStatus(`–ó–Ω–∞–π–¥–µ–Ω–æ –ø–µ—Ä–µ—Ö–æ–¥—ñ–≤: ${count}`, 'success');
    }
</script>

</body>
</html>